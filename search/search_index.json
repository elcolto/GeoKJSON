{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"GeoKJSON","text":"<p>GeoKJSON (spelled: \"Ge - OK - Json\", aligned to Squares Kotlin OK libraries like Okio) is a Kotlin Multiplatform library. Based on Spatial K by Derek Ellis this library is designed to work with geospatial data in Kotlin including an implementation of GeoJSON and a port of Turfjs written in pure Kotlin. It supports plain Kotlin and Multiplatform (KMP) projects.</p> <p>This project divided into two modules which are even released into separate artifacts.</p> <ul> <li>geojson - Containing a collection of GeoJSON structured geographic data. These are   designed to apply to WGS 84   and RFC 7946</li> <li>turf - A port of turfjs functions for spatial analysis and operations</li> </ul> <p>The goal of these libraries is to provide GeoJSON functionality for Kotlin Multiplatform projects. So encapsulation and logical operations for geographic needs can be achieved on a shared code base.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>commonMain {\n    dependencies {\n        implementation(\"io.github.elcolto.geokjson:geojson:$geokVersion\")\n        implementation(\"io.github.elcolto.geokjson:turf:$geokVersion\")\n    }\n}\n</code></pre>"},{"location":"geojson-dsl/","title":"DSL","text":""},{"location":"geojson-dsl/#geojson-dsl","title":"GeoJson DSL","text":"<p>It's recommended to construct GeoJson objects in-code using the GeoJson DSL.</p>"},{"location":"geojson-dsl/#positions","title":"Positions","text":"<p>Convenience functions to construct latitude/longitude Position instances is included. These functions will check for valid latitude and longitude values and will throw an <code>IllegalArgumentException</code> otherwise.</p> KotlinJSON <pre><code>lngLat(longitude = -75.0, latitude = 45.0)\n\n// Throws exception!!\nlngLat(longitude = -565.0, latitude = 45.0)\n</code></pre> <pre><code>[-75.0, 45.0]\n</code></pre>"},{"location":"geojson-dsl/#geometry","title":"Geometry","text":"<p>Each geometry type has a corresponding DSL.</p> <p>A GeoJson object's <code>bbox</code> value can be assigned in any of the DSLs.</p> KotlinJSON <pre><code>point(longitude = -75.0, latitude = 45.0) {\n  bbox = BoundingBox(...)\n}\n</code></pre> <pre><code>{\n  \"type\": \"Point\",\n  \"coordinates\": [-75.0, 45.0],\n  \"bbox\": [...]\n}\n</code></pre> <p><code>foreignMembers</code> property can be set via <code>AdditionalFieldsBuilder</code></p> KotlinJSON <pre><code>point(longitude = -75.0, latitude = 45.0) {\n  foreignMembers {\n    put(\"value\", 13)\n  }\n}\n</code></pre> <pre><code>   {\n  \"type\": \"Point\",\n  \"coordinates\": [-75.0, 45.0],\n  \"value\": 13\n}\n</code></pre>"},{"location":"geojson-dsl/#point","title":"Point","text":"KotlinJSON <pre><code>point(longitude = -75.0, latitude = 45.0, altitude = 100.0)\n\n// Or...\npoint(Position(12.5, 35.9))\n</code></pre> <pre><code>{\n  \"type\": \"Point\",\n  \"coordinates\": [-75.0, 45.0, 100.0]\n}\n</code></pre>"},{"location":"geojson-dsl/#multipoint","title":"MultiPoint","text":"<p>The <code>MultiPoint</code> DSL creates a <code>MultiPoint</code> from many <code>Point</code>s, or by using the unary plus operator to add <code>Position</code> instances as positions in the geometry. <code>Point</code> geometries can also be added to the multi point using the unary plus operator.</p> KotlinJSON <pre><code>val myPoint = Point(88.0, 34.0)\nmultiPoint {\n  point(-75.0, 45.0)\n\n  +lngLat(-78.0, 44.0)\n  +myPoint\n}\n</code></pre> <pre><code>{\n  \"type\": \"MultiPoint\",\n  \"coordinates\": [\n    [-75.0, 45.0],\n    [-78.0, 44.0],\n    [88.0, 34.0]\n  ]\n}\n</code></pre>"},{"location":"geojson-dsl/#linestring","title":"LineString","text":"<p>A <code>LineString</code> contains main points. Like with <code>MultiPoint</code>, a <code>LineString</code> can also be built using the unary plus operator to add positions as part of the line. The order in which positions are added to the <code>LineString</code> is the order that the <code>LineString</code> will follow.</p> KotlinJSON <pre><code>lineString {\n  point(45.0, 45.0)\n  point(0.0, 0.0)\n}\n</code></pre> <pre><code>{\n  \"type\": \"LineString\",\n  \"coordinates\": [\n    [45.0, 45.0],\n    [0.0, 0.0]\n  ]\n}\n</code></pre>"},{"location":"geojson-dsl/#multilinestring","title":"MultiLineString","text":"<p>The <code>MultiLineString</code> DSL uses the unary plus operator to add multiple line strings. The <code>LineString</code> DSL can be used to create <code>LineString</code> objects to add.</p> KotlinJSON <pre><code>val simpleLine = lineString {\n  point(45.0, 45.0)\n  point(0.0, 0.0)\n}\n\nmultiLineString {\n  +simpleLine\n\n  // Inline LineString creation\n  lineString {\n    point(44.4, 55.5)\n    point(55.5, 66.6)\n  }\n}\n</code></pre> <pre><code>{\n  \"type\": \"MultiLineString\",\n  \"coordinates\": [\n    [\n      [45.0, 45.0],\n      [0.0, 0.0]\n    ],\n    [\n      [44.4, 55.5],\n      [55.5, 66.6]\n    ]\n  ]\n}\n</code></pre>"},{"location":"geojson-dsl/#polygon","title":"Polygon","text":"<p>The <code>Polygon</code> DSL is used by specifying linear rings that make up the polygon's shape and holes. The first <code>ring</code> is the exterior ring with four or more positions. The last position must be the same as the first position. All <code>ring</code>s that follow will represent interior rings (i.e. holes) in the polygon.</p> <p>For convenience, the <code>complete()</code> function can be used to \"complete\" a ring. It adds the last position in the ring by copying the first position that was added.</p> KotlinJSON <pre><code>val simpleLine = lineString {\n  point(45.0, 45.0)\n  point(0.0, 0.0)\n}\n\npolygon {\n  ring {\n    // LineStrings can be used as part of a ring\n    +simpleLine\n    point(12.0, 12.0)\n    complete()\n  }\n  ring {\n    point(4.0, 4.0)\n    point(2.0, 2.0)\n    point(3.0, 3.0)\n    complete()\n  }\n}\n</code></pre> <pre><code>{\n  \"type\": \"Polygon\",\n  \"coordinates\": [\n    [\n      [45.0, 45.0],\n      [0.0, 0.0],\n      [12.0, 12.0],\n      [45.0, 45.0]\n    ],\n    [\n      [4.0, 4.0],\n      [2.0, 2.0],\n      [3.0, 3.0],\n      [4.0, 4.0]\n    ]\n  ]\n}\n</code></pre>"},{"location":"geojson-dsl/#multipolygon","title":"MultiPolygon","text":"<p>Like with previous \"Multi\" geometries, the unary plus operator is used to add multiple <code>Polygon</code> objects. The <code>Polygon</code> DSL can also be used here.</p> KotlinJSON <pre><code>val simplePolygon = previousExample()\n\nmultiPolygon {\n  +simplePolygon\n  polygon {\n    ring {\n      point(12.0, 0.0)\n      point(0.0, 12.0)\n      point(-12.0, 0.0)\n      point(5.0, 5.0)\n      complete()\n    }\n  }\n}\n</code></pre> <pre><code>{\n  \"type\": \"MultiPolygon\",\n  \"coordinates\": [\n    [\n      [\n        [45.0, 45.0],\n        [0.0, 0.0],\n        [12.0, 12.0],\n        [45.0, 45.0]\n      ],\n      [\n        [4.0, 4.0],\n        [2.0, 2.0],\n        [3.0, 3.0],\n        [4.0, 4.0]\n      ]\n    ],\n    [\n      [\n        [12.0, 0.0],\n        [0.0, 12.0],\n        [-12.0, 0.0],\n        [5.0, 5.0],\n        [12.0, 0.0]\n      ]\n    ]\n  ]\n}\n</code></pre>"},{"location":"geojson-dsl/#geometry-collection","title":"Geometry Collection","text":"<p>The unary plus operator can be used to add any geometry instance to a <code>GeometryCollection</code>.</p> KotlinJSON <pre><code>val simplePoint: Point = previousPoint()\nval simpleLine: LineString = previousLineString()\nval simplePolygon: Polygon = previousPolygon()\n\ngeometryCollection {\n  +simplePoint\n  +simpleLine\n  +simplePolygon\n}\n</code></pre> <pre><code>{\n  \"type\": \"GeometryCollection\",\n  \"geometries\": [\n    {\n      \"type\": \"Point\",\n      \"coordinates\": [-75.0, 45.0, 100.0]\n    },\n    {\n      \"type\": \"LineString\",\n      \"coordinates\": [\n        [45.0, 45.0],\n        [0.0, 0.0]\n      ]\n    },\n    {\n      \"type\": \"Polygon\",\n      \"coordinates\": [\n        [\n          [45.0, 45.0],\n          [0.0, 0.0],\n          [12.0, 12.0],\n          [45.0, 45.0]\n        ],\n        [\n          [4.0, 4.0],\n          [2.0, 2.0],\n          [3.0, 3.0],\n          [4.0, 4.0]\n        ]\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"geojson-dsl/#feature","title":"Feature","text":"<p>The <code>Feature</code> DSL can construct a <code>Feature</code> object with a geometry, a bounding box, and an id. Properties can be specified in the <code>PropertiesBuilder</code> block by calling <code>put(key, value)</code> to add properties.</p> KotlinJSON <pre><code>feature(geometry = point(-75.0, 45.0), id = \"point1\", bbox = BoundingBox(-76.9, 44.1, -74.2, 45.7)) {\n  put(\"name\", \"Hello World\")\n  put(\"value\", 13)\n  put(\"cool\", true)\n  put(\"numbers\", intArrayOf(1,2,3))\n}\n</code></pre> <pre><code>{\n  \"type\": \"Feature\",\n  \"id\": \"point1\",\n  \"bbox\": [\n    -76.9,\n    44.1,\n    -74.2,\n    45.7\n  ],\n  \"properties\": {\n    \"name\": \"Hello World\",\n    \"value\": 13,\n    \"cool\": true\n  },\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      -75.0,\n      45.0\n    ]\n  }\n}\n</code></pre>"},{"location":"geojson-dsl/#feature-collection","title":"Feature Collection","text":"<p>A <code>FeatureCollection</code> is constructed by adding multiple <code>Feature</code> objects using the unary plus operator.</p> KotlinJSON <pre><code>featureCollection {\n  feature(geometry = point(-75.0, 45.0))\n}\n</code></pre> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          -75.0,\n          45.0\n        ]\n      },\n      \"properties\": {}\n    }\n  ]\n}\n</code></pre>"},{"location":"geojson/","title":"GeoJson","text":"<p>The <code>geojson</code> module contains an implementation of the GeoJson standard.</p> <p>See below for constructing GeoJson objects using the DSL.</p>"},{"location":"geojson/#installation","title":"Installation","text":"KotlinGroovy <pre><code>dependencies {\n  implementation(\"io.github.elcolto.geokjson:geojson:&lt;version&gt;\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"io.github.elcolto.geokjson:geojson:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"geojson/#geojson-objects","title":"GeoJson Objects","text":"<p>The <code>GeoJson</code> interface represents all GeoJson objects. All GeoJson objects can have a <code>bbox</code> property specified on them which is a <code>BoundingBox</code> that represents the bounds of that object's geometry. According to section 6.1 of RFC 7946 each implementation of a GeoJson can contain additional properties which aren't described in the specification, so-called \"foreign members\". In GeoKJSON they are represented by an immutable <code>Map&lt;String, Any&gt;</code> structure, in which value can be a primitive, a <code>Collection&lt;Any&gt;</code> or a recursively structured <code>Map&lt;String,Any&gt;</code> of the same types. Custom Types are not supported.</p>"},{"location":"geojson/#geometry","title":"Geometry","text":"<p>Geometry objects are a sealed hierarchy of classes that inherit from the <code>Geometry</code> class. This allows for exhaustive type checks in Kotlin using a <code>when</code> block.</p> Kotlin <pre><code>val geometry: Geometry = getSomeGeometry()\n\n    val type = when (geometry) {\n        is Point -&gt; \"Point\"\n        is MultiPoint -&gt; \"MultiPoint\"\n        is LineString -&gt; \"LineString\"\n        is MultiLineString -&gt; \"MultiLineString\"\n        is Polygon -&gt; \"Polygon\"\n        is MultiPolygon -&gt; \"MultiPolygon\"\n        is GeometryCollection -&gt; \"GeometryCollection\"\n    }\n</code></pre> <p>All seven types of GeoJSON geometries are implemented and summarized below. Full documentation can be found in the API pages.</p>"},{"location":"geojson/#position","title":"Position","text":"<p>Positions are implemented as a <code>DoubleArray</code>-backed class. Each component (<code>longitude</code>, <code>latitude</code>, <code>altitude</code>) can be accessed by its propery. The class also supports destructuring.</p> <p>Positions are implemented as an interface where the longitude, latitude, and optionally an altitude are accessible as properties. The basic implementation of the <code>Position</code> interface is the <code>LngLat</code> class.</p> KotlinJSON <pre><code>val position: Position = Position(-75.0, 45.0)\nval (longitude, latitude, altitude) = position\n\n    // Access values\n    position.longitude\n    position.latitude\n    position.altitude // null if unspecified\n</code></pre> <pre><code>[-75, 45]\n</code></pre>"},{"location":"geojson/#point","title":"Point","text":"<p>A Point is a single Position.</p> KotlinJSON <pre><code>val point = Point(Position(-75.0, 45.0))\n\nprintln(point.longitude)\n// Prints: -75.0\n</code></pre> <pre><code>{\n  \"type\": \"Point\",\n  \"coordinates\": [-75, 45]\n}\n</code></pre>"},{"location":"geojson/#multipoint","title":"MultiPoint","text":"<p>A <code>MultiPoint</code> is an array of Positions.</p> KotlinJSON <pre><code>val multiPoint = MultiPoint(Position(-75.0, 45.0), Position(-79.0, 44.0))\n</code></pre> <pre><code>{\n  \"type\": \"MultiPoint\",\n  \"coordinates\": [\n    [-75, 45],\n    [-79, 44]\n  ]\n}\n</code></pre>"},{"location":"geojson/#linestring","title":"LineString","text":"<p>A <code>LineString</code> is a sequence of two or more Positions.</p> KotlinJSON <pre><code>val lineString = LineString(Position(-75.0, 45.0), Position(-79.0, 44.0))\n</code></pre> <pre><code>{\n  \"type\": \"LineString\",\n  \"coordinates\": [\n    [\n      -75,\n      45\n    ],\n    [\n      -79,\n      44\n    ]\n  ]\n}\n</code></pre>"},{"location":"geojson/#multilinestring","title":"MultiLineString","text":"<p>A <code>MultiLineString</code> is an array of LineStrings.</p> KotlinJSON <pre><code>val multiLineString = MultiLineString(\n  listOf(Position(12.3, 45.6), Position(78.9, 12.3)),\n  listOf(Position(87.6, 54.3), Position(21.9, 56.4))\n)\n</code></pre> <pre><code>{\n  \"type\": \"MultiLineString\",\n  \"coordinates\": [\n    [\n      [12.3, 45.6],\n      [78.9, 12.3]\n    ],\n    [\n      [87.6, 54.3],\n      [21.9, 56.4]\n    ]\n  ]\n}\n</code></pre>"},{"location":"geojson/#polygon","title":"Polygon","text":"<p>A <code>Polygon</code> is an array of rings. Each ring is a sequence of points with the last point matching the first point to indicate a closed area. The first ring defines the outer shape of the polygon, while all the following rings define \"holes\" inside the polygon.</p> KotlinJSON <pre><code>val polygon = Polygon(\n  listOf(\n    Position(-79.87, 43.42),\n    Position(-78.89, 43.49),\n    Position(-79.07, 44.02),\n    Position(-79.95, 43.87),\n    Position(-79.87, 43.42)\n  ),\n  listOf(\n    Position(-79.75, 43.81),\n    Position(-79.56, 43.85),\n    Position(-79.7, 43.88),\n    Position(-79.75, 43.81)\n  )\n)\n</code></pre> <pre><code>{\n  \"type\": \"Polygon\",\n  \"coordinates\": [\n    [\n      [\n        -79.87,\n        43.42\n      ],\n      [-78.89, 43.49],\n      [-79.07, 44.02],\n      [-79.95, 43.87],\n      [-79.87, 43.42]\n    ],\n    [\n      [-79.75, 43.81],\n      [-79.56, 43.85],\n      [-79.7, 43.88],\n      [-79.75, 43.81]\n    ]\n  ]\n}\n</code></pre>"},{"location":"geojson/#multipolygon","title":"MultiPolygon","text":"<p>A <code>MultiPolygon</code> is an array of Polygons.</p> KotlinJSON <pre><code>val polygon = listOf(\n  Position(-79.87, 43.42),\n  Position(-78.89, 43.49),\n  Position(-79.07, 44.02),\n  Position(-79.95, 43.87),\n  Position(-79.87, 43.42)\n),\nlistOf(\n  Position(-79.75, 43.81),\n  Position(-79.56, 43.85),\n  Position(-79.7, 43.88),\n  Position(-79.75, 43.81)\n)\nval multiPolygon = MultiPolygon(polygon, polygon)\n</code></pre> <pre><code>{\n  \"type\": \"MultiPolygon\",\n  \"coordinates\": [\n    [\n      [\n        [-79.87, 43.42],\n        [-78.89, 43.49],\n        [-79.07, 44.02],\n        [-79.95, 43.87],\n        [-79.87, 43.42]\n      ],\n      [\n        [-79.75, 43.81],\n        [-79.56, 43.85],\n        [-79.7, 43.88],\n        [-79.75, 43.81]\n      ]\n    ],\n    [\n      [\n        [-79.87, 43.42],\n        [-78.89, 43.49],\n        [-79.07, 44.02],\n        [-79.95, 43.87],\n        [-79.87, 43.42]\n      ],\n      [\n        [-79.75, 43.81],\n        [-79.56, 43.85],\n        [-79.7, 43.88],\n        [-79.75, 43.81]\n      ]\n    ]\n  ]\n}\n</code></pre>"},{"location":"geojson/#geometrycollection","title":"GeometryCollection","text":"<p>A <code>GeometryCollection</code> is a collection of different types of Geometry. It implements the <code>Collection</code> interface and can be used in any place that a collection can be used.</p> KotlinJSON <pre><code>val geometryCollection = GeometryCollection(point, lineString)\n\n// Can be iterated over, and used in any way a Collection&lt;T&gt; can be\ngeometryCollection.forEach { geometry -&gt;\n  // ...\n}\n</code></pre> <pre><code>{\n  \"type\": \"GeometryCollection\",\n  \"coordinates\": [\n    {\n      \"type\": \"Point\",\n      \"coordinates\": [-75, 45]\n    },\n    {\n      \"type\": \"LineString\",\n      \"coordinates\": [\n        [-75, 45],\n        [-79, 44]\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"geojson/#feature","title":"Feature","text":"<p>A <code>Feature</code> can contain a <code>Geometry</code> object, as well as a set of data properties, and optionally a commonly used identifier (<code>id</code>).</p> <p>A feature's properties are stored as an immutable <code>Map&lt;String, Any&gt;</code> structure. A set of helper methods to get and set properties with the appropriate types directly.</p> KotlinJSON <pre><code>val feature = Feature(point)\n\nval size: Number? = feature.properties[\"size\"] // 9999\nval geometry: Geometry? = feature.geometry // point\n</code></pre> <pre><code>{\n  \"type\": \"Feature\",\n  \"geometry\": {\n    \"type\": \"Point\",\n    \"coordinates\": [\n      -75,\n      45\n    ]\n  },\n  \"properties\": {\n    \"size\": 9999\n  }\n}\n</code></pre>"},{"location":"geojson/#featurecollection","title":"FeatureCollection","text":"<p>A <code>FeatureCollection</code> is a collection of multiple features. <code>FeatureCollection</code> implements the <code>Collection</code> interface and can be used in any place that a collection can be used.</p> KotlinJSON <pre><code>val featureCollection = FeatureCollection(pointFeature)\n\nfeatureCollection.forEach { feature -&gt;\n  // ...\n}\n</code></pre> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [\n          -75,\n          45\n        ]\n      },\n      \"properties\": {\n        \"size\": 9999\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"geojson/#boundingbox","title":"BoundingBox","text":"<p>The <code>BoundingBox</code> class is used to represent the bounding boxes that can be set for any <code>GeoJson</code> object. Like the <code>Position</code> class, bounding boxes are backed by a <code>DoubleArray</code> with each component accessible by its propery (<code>southwest</code> and <code>northeast</code>). Bounding boxes also support destructuring.</p> KotlinJSON <pre><code>val bbox = BoundingBox(west = 11.6, south = 45.1, east = 12.7, north = 45.7)\nval (southwest, northeast) = bbox // Two Positions\n</code></pre> <pre><code>[11.6, 45.1, 12.7, 45.7]\n</code></pre>"},{"location":"geojson/#serialization","title":"Serialization","text":""},{"location":"geojson/#to-json","title":"To Json","text":"<p>Any <code>GeoJson</code> object can be serialized to a JSON string using the <code>json()</code> function. This function converts the object to JSON using string concatenation and is therefore very fast.</p> Kotlin <pre><code>val featureCollection: FeatureCollection = getFeatureCollection()\n\n    val json = featureCollection.json()\n    println(json)\n</code></pre> <p>Spatial-K is also fully compatible with <code>kotlinx.serialization</code> to allow for integration into more complex models, however this is much slower. For encoding directly to JSON strings, prefer to use the <code>json()</code> function.</p>"},{"location":"geojson/#from-json","title":"From Json","text":"<p>The <code>fromJson</code> and <code>fromJsonOrNull</code> companion (or static) functions are available on each <code>GeoJson</code> class to decode each type of object from a JSON string.</p> KotlinJava <pre><code>// Throws exception if the JSON cannot be deserialized to a Point\nval myPoint = Point.fromJson(\"{...geojson...}\")\n\n// Returns null if an error occurs\nval nullable = Point.fromJsonOrNull(\"{...not a point...}\")\n</code></pre> <pre><code>// Throws exception if the JSON cannot be deserialized to a Point\nvar myPoint = Point.fromJson(\"{...geojson...}\");\n\n// Returns null if an error occurs\nvar nullable = Point.fromJsonOrNull(\"{...not a point...}\");\n</code></pre> <p>Like with encoding, Spatial-K objects can also be decoded using <code>kotlinx.serialization</code>.</p> Kotlin <pre><code>val feature: Feature = Json.decodeFromString(Feature.serializer(), \"{...feature...}\")\n</code></pre>"},{"location":"ported-functions/","title":"Ported Functions","text":"<p>The following functions have been ported from turfjs.</p>"},{"location":"ported-functions/#measurement","title":"Measurement","text":"<ul> <li> <code>along</code></li> <li> <code>area</code></li> <li> <code>bbox</code></li> <li> <code>bboxPolygon</code></li> <li> <code>bearing</code></li> <li> <code>center</code></li> <li> <code>centerOfMass</code></li> <li> <code>centroid</code></li> <li> <code>destination</code></li> <li> <code>distance</code></li> <li> <code>envelope</code></li> <li> <code>greatCircle</code></li> <li> <code>length</code></li> <li> <code>midpoint</code></li> <li> <code>pointOnFeature</code></li> <li> <code>polygonTangents</code></li> <li> <code>pointToLineDistance</code></li> <li> <code>rhumbBearing</code></li> <li> <code>rhumbDestination</code></li> <li> <code>rhumbDistance</code></li> <li> <code>square</code></li> </ul>"},{"location":"ported-functions/#coordinate-mutation","title":"Coordinate Mutation","text":"<ul> <li> <code>cleanCoords</code></li> <li> <code>flip</code></li> <li> <code>rewind</code></li> <li> <code>round</code>   Use <code>round</code> or <code>Math.round</code> from the standard library instead.</li> <li> <code>truncate</code></li> </ul>"},{"location":"ported-functions/#transformation","title":"Transformation","text":"<ul> <li> <code>bboxClip</code></li> <li> <code>bezierSpline</code></li> <li> <code>buffer</code></li> <li> <code>circle</code></li> <li> <code>clone</code></li> <li> <code>concave</code></li> <li> <code>convex</code></li> <li> <code>difference</code></li> <li> <code>dissolve</code></li> <li> <code>intersect</code></li> <li> <code>lineOffset</code></li> <li> <code>simplify</code></li> <li> <code>tessellate</code></li> <li> <code>transformRotate</code></li> <li> <code>transformTranslate</code></li> <li> <code>transformScale</code></li> <li> <code>union</code></li> <li> <code>voronoi</code></li> </ul>"},{"location":"ported-functions/#feature-conversion","title":"Feature Conversion","text":"<ul> <li> <code>combine</code></li> <li> <code>explode</code></li> <li> <code>flatten</code></li> <li> <code>lineToPolygon</code></li> <li> <code>polygonize</code></li> <li> <code>polygonToLine</code></li> </ul>"},{"location":"ported-functions/#miscellaneous","title":"Miscellaneous","text":"<ul> <li> <code>kinks</code></li> <li> <code>lineArc</code></li> <li> <code>lineChunk</code></li> <li> <code>lineIntersect</code>   Partially implemented.</li> <li> <code>lineOverlap</code></li> <li> <code>lineSegment</code></li> <li> <code>lineSlice</code></li> <li> <code>lineSliceAlong</code></li> <li> <code>lineSplit</code></li> <li> <code>mask</code></li> <li> <code>nearestPointOnLine</code></li> <li> <code>sector</code></li> <li> <code>shortestPath</code></li> <li> <code>unkinkPolygon</code></li> </ul>"},{"location":"ported-functions/#helper","title":"Helper","text":"<p>Use the GeoJson DSL instead.</p>"},{"location":"ported-functions/#random","title":"Random","text":"<ul> <li> <code>randomPosition</code></li> <li> <code>randomPoint</code></li> <li> <code>randomLineString</code></li> <li> <code>randomPolygon</code></li> </ul>"},{"location":"ported-functions/#data","title":"Data","text":"<ul> <li> <code>sample</code></li> </ul>"},{"location":"ported-functions/#interpolation","title":"Interpolation","text":"<ul> <li> <code>interpolate</code></li> <li> <code>isobands</code></li> <li> <code>isolines</code></li> <li> <code>planepoint</code></li> <li> <code>tin</code></li> </ul>"},{"location":"ported-functions/#joins","title":"Joins","text":"<ul> <li> <code>pointsWithinPolygon</code></li> <li> <code>tag</code></li> </ul>"},{"location":"ported-functions/#grids","title":"Grids","text":"<ul> <li> <code>hexGrid</code></li> <li> <code>pointGrid</code></li> <li> <code>squareGrid</code></li> <li> <code>triangleGrid</code></li> </ul>"},{"location":"ported-functions/#classification","title":"Classification","text":"<ul> <li> <code>nearestPoint</code></li> </ul>"},{"location":"ported-functions/#aggregation","title":"Aggregation","text":"<ul> <li> <code>collect</code></li> <li> <code>clustersDbscan</code></li> <li> <code>clustersKmeans</code></li> </ul>"},{"location":"ported-functions/#meta","title":"Meta","text":"<ul> <li> <code>coordAll</code></li> <li> <code>coordEach</code></li> <li> <code>coordReduce</code></li> <li> <code>featureEach</code></li> <li> <code>featureReduce</code></li> <li> <code>flattenEach</code></li> <li> <code>flattenReduce</code></li> <li> <code>getCoord</code></li> <li> <code>getCoords</code></li> <li> <code>getGeom</code></li> <li> <code>getType</code></li> <li> <code>geomEach</code></li> <li> <code>geomReduce</code></li> <li> <code>propEach</code></li> <li> <code>segmentEach</code></li> <li> <code>segmentReduce</code></li> <li> <code>getCluster</code></li> <li> <code>clusterEach</code></li> <li> <code>clusterReduce</code></li> </ul>"},{"location":"ported-functions/#assertations","title":"Assertations","text":"<ul> <li> <code>collectionOf</code></li> <li> <code>containsNumber</code></li> <li> <code>geojsonType</code></li> <li> <code>featureOf</code></li> </ul>"},{"location":"ported-functions/#booleans","title":"Booleans","text":"<ul> <li> <code>booleanClockwise</code></li> <li> <code>booleanContains</code></li> <li> <code>booleanCrosses</code></li> <li> <code>booleanDisjoint</code></li> <li> <code>booleanEqual</code></li> <li> <code>booleanOverlap</code></li> <li> <code>booleanParallel</code></li> <li> <code>booleanPointInPolygon</code></li> <li> <code>booleanPointOnLine</code></li> <li> <code>booleanTouches</code></li> <li> <code>booleanWithin</code></li> </ul>"},{"location":"ported-functions/#unit-conversion","title":"Unit Conversion","text":"<ul> <li> <code>bearingToAzimuth</code></li> <li> <code>convertArea</code></li> <li> <code>convertLength</code></li> <li> <code>degreesToRadians</code></li> <li> <code>lengthToRadians</code></li> <li> <code>lengthToDegrees</code></li> <li> <code>radiansToLength</code></li> <li> <code>radiansToDegrees</code></li> <li> <code>toMercator</code></li> <li> <code>toWgs84</code></li> </ul>"},{"location":"turf/","title":"Turf","text":"<p>Turfjs is a spatial analysis library for JavaScript applications and the <code>turf</code> module contains a Kotlin port of it with support for Kotlin Multiplatform projects.</p> <p>This module makes use of the classes defined in the <code>geojson</code> module as the GeoJson inputs to many of the turf functions.</p> <p>The documentation for the ported functions can be found in the API docs, while more details on each function can be found on the Turfjs site.</p>"},{"location":"turf/#installation","title":"Installation","text":"KotlinGroovy <pre><code>dependencies {\n  implementation(\"io.github.elcolto.geokjson:turf:&lt;version&gt;\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"io.github.dellisd.spatialk:turf:&lt;version&gt;\"\n}\n</code></pre>"},{"location":"turf/#example","title":"Example","text":"<p>Turf functions are available as top-level functions in Kotlin, or as static member functions in Java.</p> Kotlin <pre><code>val point = LngLat(-75.0, 45.0)\nval (longitude, latitude) = destination(point, 100.0, 0.0)\n</code></pre>"},{"location":"turf/#turf-functions","title":"Turf Functions","text":"<p>A list of all turf functions and their current status in the port can be found on this page.</p>"},{"location":"turf/#units-of-measurement","title":"Units of Measurement","text":"<p>Units of measurement are represented using the <code>Units</code> enum. These enum values can be passed into functions to specify the units used by other values passed into the function.</p> Kotlin <pre><code>val result = convertLength(12.5, from = Units.Kilometers, to = Units.Miles)\n</code></pre> <p>Not all units are valid for every function. For example: acres cannot be used as a measure of distance. Calling a function like <code>convertLength</code> with <code>Units.Acres</code> as one of the arguments will cause an <code>IllegalArgumentException</code>.</p>"}]}